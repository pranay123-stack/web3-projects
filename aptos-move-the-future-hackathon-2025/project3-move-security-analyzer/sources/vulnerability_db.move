module security_analyzer::vulnerability_db {
    use std::error;
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use aptos_framework::event;
    use aptos_framework::timestamp;

    /// Error codes
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_PATTERN_NOT_FOUND: u64 = 2;
    const E_ALREADY_EXISTS: u64 = 3;

    /// Vulnerability pattern
    struct VulnerabilityPattern has store, drop, copy {
        /// Pattern ID
        pattern_id: u64,
        /// Pattern name
        name: String,
        /// Category
        category: u8,
        /// Default severity
        severity: u8,
        /// Description
        description: String,
        /// Code pattern to detect
        code_pattern: String,
        /// Recommendation
        recommendation: String,
        /// CWE ID (Common Weakness Enumeration)
        cwe_id: String,
        /// Times detected
        detection_count: u64,
        /// Pattern added timestamp
        added_at: u64,
    }

    /// CVE (Common Vulnerabilities and Exposures) entry
    struct CVEEntry has store, drop, copy {
        cve_id: String,
        title: String,
        description: String,
        severity: u8,
        affected_versions: String,
        patch_available: bool,
        disclosure_date: u64,
    }

    /// Vulnerability database state
    struct VulnerabilityDB has key {
        /// Known vulnerability patterns
        patterns: vector<VulnerabilityPattern>,
        /// CVE entries
        cves: vector<CVEEntry>,
        /// Next pattern ID
        next_pattern_id: u64,
        /// Admin address
        admin: address,
    }

    /// Events
    #[event]
    struct PatternAdded has drop, store {
        pattern_id: u64,
        name: String,
        severity: u8,
        timestamp: u64,
    }

    #[event]
    struct PatternDetected has drop, store {
        pattern_id: u64,
        name: String,
        contract_address: address,
        timestamp: u64,
    }

    #[event]
    struct CVEAdded has drop, store {
        cve_id: String,
        severity: u8,
        timestamp: u64,
    }

    /// Initialize vulnerability database
    public entry fun initialize_db(admin: &signer) {
        let admin_addr = signer::address_of(admin);

        move_to(admin, VulnerabilityDB {
            patterns: vector::empty(),
            cves: vector::empty(),
            next_pattern_id: 1,
            admin: admin_addr,
        });
    }

    /// Add vulnerability pattern (admin only)
    public entry fun add_pattern(
        admin: &signer,
        name: String,
        category: u8,
        severity: u8,
        description: String,
        code_pattern: String,
        recommendation: String,
        cwe_id: String,
    ) acquires VulnerabilityDB {
        let admin_addr = signer::address_of(admin);
        let db = borrow_global_mut<VulnerabilityDB>(@security_analyzer);

        assert!(admin_addr == db.admin, error::permission_denied(E_NOT_AUTHORIZED));

        let pattern = VulnerabilityPattern {
            pattern_id: db.next_pattern_id,
            name,
            category,
            severity,
            description,
            code_pattern,
            recommendation,
            cwe_id,
            detection_count: 0,
            added_at: timestamp::now_seconds(),
        };

        vector::push_back(&mut db.patterns, pattern);
        db.next_pattern_id = db.next_pattern_id + 1;

        event::emit(PatternAdded {
            pattern_id: pattern.pattern_id,
            name,
            severity,
            timestamp: timestamp::now_seconds(),
        });
    }

    /// Record pattern detection
    public entry fun record_detection(
        _auditor: &signer,
        pattern_id: u64,
        contract_address: address,
    ) acquires VulnerabilityDB {
        let db = borrow_global_mut<VulnerabilityDB>(@security_analyzer);

        let pattern_index = find_pattern(&db.patterns, pattern_id);
        assert!(pattern_index < vector::length(&db.patterns),
            error::not_found(E_PATTERN_NOT_FOUND));

        let pattern = vector::borrow_mut(&mut db.patterns, pattern_index);
        pattern.detection_count = pattern.detection_count + 1;

        event::emit(PatternDetected {
            pattern_id,
            name: pattern.name,
            contract_address,
            timestamp: timestamp::now_seconds(),
        });
    }

    /// Add CVE entry (admin only)
    public entry fun add_cve(
        admin: &signer,
        cve_id: String,
        title: String,
        description: String,
        severity: u8,
        affected_versions: String,
        patch_available: bool,
        disclosure_date: u64,
    ) acquires VulnerabilityDB {
        let admin_addr = signer::address_of(admin);
        let db = borrow_global_mut<VulnerabilityDB>(@security_analyzer);

        assert!(admin_addr == db.admin, error::permission_denied(E_NOT_AUTHORIZED));

        let cve = CVEEntry {
            cve_id,
            title,
            description,
            severity,
            affected_versions,
            patch_available,
            disclosure_date,
        };

        vector::push_back(&mut db.cves, cve);

        event::emit(CVEAdded {
            cve_id,
            severity,
            timestamp: timestamp::now_seconds(),
        });
    }

    /// Helper: Find pattern by ID
    fun find_pattern(patterns: &vector<VulnerabilityPattern>, pattern_id: u64): u64 {
        let i = 0u64;
        let len = vector::length(patterns);
        while (i < len) {
            let pattern = vector::borrow(patterns, i);
            if (pattern.pattern_id == pattern_id) {
                return i
            };
            i = i + 1;
        };
        len
    }

    /// View: Get pattern details
    #[view]
    public fun get_pattern_details(pattern_id: u64): (
        String,   // name
        u8,       // category
        u8,       // severity
        String,   // description
        String,   // recommendation
        u64,      // detection_count
    ) acquires VulnerabilityDB {
        let db = borrow_global<VulnerabilityDB>(@security_analyzer);
        let pattern_index = find_pattern(&db.patterns, pattern_id);
        assert!(pattern_index < vector::length(&db.patterns),
            error::not_found(E_PATTERN_NOT_FOUND));

        let pattern = vector::borrow(&db.patterns, pattern_index);
        (
            pattern.name,
            pattern.category,
            pattern.severity,
            pattern.description,
            pattern.recommendation,
            pattern.detection_count,
        )
    }

    /// View: Get database statistics
    #[view]
    public fun get_db_stats(): (u64, u64) acquires VulnerabilityDB {
        let db = borrow_global<VulnerabilityDB>(@security_analyzer);
        (
            vector::length(&db.patterns),
            vector::length(&db.cves),
        )
    }

    /// View: Get all pattern IDs
    #[view]
    public fun get_all_patterns(): vector<u64> acquires VulnerabilityDB {
        let db = borrow_global<VulnerabilityDB>(@security_analyzer);
        let result = vector::empty<u64>();

        let i = 0u64;
        let len = vector::length(&db.patterns);

        while (i < len) {
            let pattern = vector::borrow(&db.patterns, i);
            vector::push_back(&mut result, pattern.pattern_id);
            i = i + 1;
        };

        result
    }
}
