import {
  Vulnerability,
  VulnerabilityPattern,
  VulnerabilitySeverity,
  VulnerabilityCategory,
  ProgramInfo,
  BytecodeAnalysis,
  SecurityCheck,
  CheckStatus,
} from '../types';
import { generateAuditId, severityToNumber } from '../utils/helpers';
import logger from '../utils/logger';

// Predefined vulnerability patterns
const VULNERABILITY_PATTERNS: VulnerabilityPattern[] = [
  {
    id: 'UPGRADE_AUTHORITY_NOT_REVOKED',
    name: 'Upgrade Authority Not Revoked',
    category: 'UPGRADE_RISK',
    severity: 'HIGH',
    description: 'Program can be upgraded by the authority, potentially introducing malicious code',
    pattern: () => true, // Checked via program info
    recommendation: 'Consider revoking upgrade authority if program is finalized, or ensure authority is a multisig',
    cweId: 'CWE-284',
    references: ['https://docs.solana.com/cli/deploy-a-program#final-deployment'],
  },
  {
    id: 'MISSING_SIGNER_CHECK',
    name: 'Missing Signer Verification',
    category: 'SIGNER_AUTHORIZATION',
    severity: 'CRITICAL',
    description: 'Instruction does not verify that required accounts have signed the transaction',
    pattern: () => true,
    recommendation: 'Always verify is_signer for accounts that should authorize the transaction',
    cweId: 'CWE-862',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/2-signer-authorization/README.md'],
  },
  {
    id: 'MISSING_OWNER_CHECK',
    name: 'Missing Owner Verification',
    category: 'OWNERSHIP',
    severity: 'CRITICAL',
    description: 'Account ownership is not verified before accessing data',
    pattern: () => true,
    recommendation: 'Always verify account.owner equals expected program before accessing account data',
    cweId: 'CWE-284',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/3-owner-checks/README.md'],
  },
  {
    id: 'INTEGER_OVERFLOW',
    name: 'Potential Integer Overflow',
    category: 'ARITHMETIC',
    severity: 'HIGH',
    description: 'Arithmetic operations may overflow without checked math',
    pattern: () => true,
    recommendation: 'Use checked_add, checked_sub, checked_mul, or Rust\'s overflow-checks feature',
    cweId: 'CWE-190',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/4-integer-overflow/README.md'],
  },
  {
    id: 'ACCOUNT_DATA_MATCHING',
    name: 'Missing Account Data Validation',
    category: 'DATA_VALIDATION',
    severity: 'MEDIUM',
    description: 'Account data constraints may not be properly validated',
    pattern: () => true,
    recommendation: 'Validate all account data matches expected values before processing',
    cweId: 'CWE-20',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/5-account-data-matching/README.md'],
  },
  {
    id: 'UNSAFE_PDA_SHARING',
    name: 'Unsafe PDA Derivation',
    category: 'PDA_VALIDATION',
    severity: 'HIGH',
    description: 'PDA may be derivable with different seeds, allowing unauthorized access',
    pattern: () => true,
    recommendation: 'Use unique, non-guessable seeds for PDA derivation and verify bump seed',
    cweId: 'CWE-330',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/6-duplicate-mutable-accounts/README.md'],
  },
  {
    id: 'UNINITIALIZED_ACCOUNT',
    name: 'Uninitialized Account Access',
    category: 'INITIALIZATION',
    severity: 'HIGH',
    description: 'Account may be accessed before proper initialization',
    pattern: () => true,
    recommendation: 'Use discriminator/is_initialized pattern to prevent uninitialized access',
    cweId: 'CWE-908',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/7-insecure-initialization/README.md'],
  },
  {
    id: 'ARBITRARY_CPI',
    name: 'Unchecked Cross-Program Invocation',
    category: 'CROSS_PROGRAM',
    severity: 'CRITICAL',
    description: 'CPI target program is not validated, allowing calls to arbitrary programs',
    pattern: () => true,
    recommendation: 'Verify CPI target program_id matches expected program before invoke',
    cweId: 'CWE-829',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/8-arbitrary-cpi/README.md'],
  },
  {
    id: 'DUPLICATE_MUTABLE_ACCOUNTS',
    name: 'Duplicate Mutable Accounts',
    category: 'ACCOUNT_VALIDATION',
    severity: 'HIGH',
    description: 'Same account passed multiple times as mutable, causing data corruption',
    pattern: () => true,
    recommendation: 'Verify all mutable account keys are unique before processing',
    cweId: 'CWE-362',
    references: ['https://github.com/coral-xyz/sealevel-attacks/blob/master/programs/6-duplicate-mutable-accounts/README.md'],
  },
  {
    id: 'MISSING_RENT_EXEMPTION',
    name: 'Missing Rent Exemption Check',
    category: 'CONFIGURATION',
    severity: 'LOW',
    description: 'Account may not have sufficient lamports to be rent-exempt',
    pattern: () => true,
    recommendation: 'Ensure accounts are funded for rent exemption or use rent sysvar',
    cweId: 'CWE-400',
    references: ['https://docs.solana.com/developing/programming-model/accounts#rent'],
  },
];

export class VulnerabilityDetector {
  private patterns: VulnerabilityPattern[];

  constructor(customPatterns?: VulnerabilityPattern[]) {
    this.patterns = [...VULNERABILITY_PATTERNS, ...(customPatterns || [])];
  }

  /**
   * Detect vulnerabilities in program
   */
  async detectVulnerabilities(
    programInfo: ProgramInfo,
    bytecodeAnalysis: BytecodeAnalysis
  ): Promise<Vulnerability[]> {
    logger.info(`Running vulnerability detection for ${programInfo.programId}`);

    const vulnerabilities: Vulnerability[] = [];

    // 1. Check upgrade authority risk
    if (programInfo.isUpgradeable && programInfo.upgradeAuthority) {
      vulnerabilities.push(this.createVulnerability(
        'UPGRADE_AUTHORITY_NOT_REVOKED',
        {
          description: `Program is upgradeable. Upgrade authority: ${programInfo.upgradeAuthority}`,
          impact: 'Malicious code could be deployed without user consent',
          confidence: 1.0,
        }
      ));
    }

    // 2. Analyze instruction-level security
    for (const instruction of bytecodeAnalysis.instructions) {
      // Check signer validation
      if (!instruction.hasSignerCheck) {
        vulnerabilities.push(this.createVulnerability(
          'MISSING_SIGNER_CHECK',
          {
            description: `Instruction ${instruction.name} may not verify signer`,
            location: { instruction: instruction.name },
            confidence: 0.7,
          }
        ));
      }

      // Check owner validation
      if (!instruction.hasOwnerCheck && instruction.modifiesState) {
        vulnerabilities.push(this.createVulnerability(
          'MISSING_OWNER_CHECK',
          {
            description: `Instruction ${instruction.name} modifies state without apparent owner check`,
            location: { instruction: instruction.name },
            confidence: 0.6,
          }
        ));
      }
    }

    // 3. Check arithmetic patterns
    const arithmeticPattern = bytecodeAnalysis.patterns.find(
      p => p.name === 'Heavy Arithmetic'
    );
    if (arithmeticPattern && arithmeticPattern.occurrences > 10) {
      vulnerabilities.push(this.createVulnerability(
        'INTEGER_OVERFLOW',
        {
          description: `${arithmeticPattern.occurrences} arithmetic operations detected`,
          impact: 'Calculations may overflow causing incorrect values or exploitation',
          confidence: 0.5,
        }
      ));
    }

    // 4. Check cross-program invocations
    const unknownCPI = bytecodeAnalysis.crossProgramCalls.find(
      c => c.targetProgram === 'unknown'
    );
    if (unknownCPI) {
      vulnerabilities.push(this.createVulnerability(
        'ARBITRARY_CPI',
        {
          description: 'Cross-program invocation to unidentified program',
          impact: 'Could allow calls to malicious programs',
          confidence: 0.6,
        }
      ));
    }

    // 5. Check deployer reputation
    if (programInfo.deployerHistory) {
      const deployer = programInfo.deployerHistory;
      if (deployer.reputation === 'NEW' || deployer.reputation === 'UNKNOWN') {
        vulnerabilities.push({
          id: generateAuditId(),
          name: 'New/Unknown Deployer',
          severity: 'MEDIUM',
          category: 'CONFIGURATION',
          description: `Program deployed by ${deployer.reputation.toLowerCase()} wallet (${deployer.walletAge} days old)`,
          impact: 'Less accountability and track record',
          recommendation: 'Verify deployer identity and reputation before interacting',
          references: [],
          confidence: 0.8,
        });
      }
    }

    // 6. Check for division operations
    const divPattern = bytecodeAnalysis.patterns.find(p => p.name === 'Division Operations');
    if (divPattern) {
      vulnerabilities.push({
        id: generateAuditId(),
        name: 'Potential Division by Zero',
        severity: 'MEDIUM',
        category: 'ARITHMETIC',
        description: `${divPattern.occurrences} division operations detected`,
        impact: 'May panic or produce unexpected results if divisor is zero',
        recommendation: 'Ensure divisor is checked before division operations',
        references: [],
        cweId: 'CWE-369',
        confidence: 0.5,
      });
    }

    // Sort by severity
    return this.sortBySeverity(vulnerabilities);
  }

  /**
   * Run security checks
   */
  async runSecurityChecks(
    programInfo: ProgramInfo,
    bytecodeAnalysis: BytecodeAnalysis
  ): Promise<SecurityCheck[]> {
    const checks: SecurityCheck[] = [];

    // Check 1: Upgrade Authority
    checks.push({
      id: 'CHK_UPGRADE',
      name: 'Upgrade Authority Status',
      category: 'Configuration',
      status: !programInfo.isUpgradeable || !programInfo.upgradeAuthority ? 'PASSED' : 'WARNING',
      severity: 'HIGH',
      description: programInfo.upgradeAuthority
        ? `Upgradeable - Authority: ${programInfo.upgradeAuthority}`
        : 'Not upgradeable or authority revoked',
    });

    // Check 2: Program Size
    const reasonableSize = bytecodeAnalysis.size < 500000; // 500KB
    checks.push({
      id: 'CHK_SIZE',
      name: 'Program Size',
      category: 'Configuration',
      status: reasonableSize ? 'PASSED' : 'WARNING',
      severity: 'LOW',
      description: `Program size: ${(bytecodeAnalysis.size / 1024).toFixed(2)} KB`,
      details: reasonableSize ? undefined : 'Large program size may indicate complexity',
    });

    // Check 3: Signer Validation
    const hasSignerChecks = bytecodeAnalysis.instructions.some(i => i.hasSignerCheck);
    checks.push({
      id: 'CHK_SIGNER',
      name: 'Signer Verification',
      category: 'Access Control',
      status: hasSignerChecks ? 'PASSED' : 'FAILED',
      severity: 'CRITICAL',
      description: hasSignerChecks
        ? 'Signer verification patterns detected'
        : 'No signer verification patterns detected',
    });

    // Check 4: Owner Validation
    const hasOwnerChecks = bytecodeAnalysis.instructions.some(i => i.hasOwnerCheck);
    checks.push({
      id: 'CHK_OWNER',
      name: 'Owner Verification',
      category: 'Access Control',
      status: hasOwnerChecks ? 'PASSED' : 'WARNING',
      severity: 'HIGH',
      description: hasOwnerChecks
        ? 'Owner verification patterns detected'
        : 'Owner verification may be missing',
    });

    // Check 5: Cross-Program Calls
    const cpiCount = bytecodeAnalysis.crossProgramCalls.length;
    const hasUnknownCPI = bytecodeAnalysis.crossProgramCalls.some(c => c.targetProgram === 'unknown');
    checks.push({
      id: 'CHK_CPI',
      name: 'Cross-Program Invocations',
      category: 'External Calls',
      status: hasUnknownCPI ? 'WARNING' : cpiCount > 0 ? 'PASSED' : 'PASSED',
      severity: hasUnknownCPI ? 'MEDIUM' : 'INFORMATIONAL',
      description: `${cpiCount} cross-program calls detected`,
      details: bytecodeAnalysis.crossProgramCalls.map(c => c.targetProgram).join(', '),
    });

    // Check 6: Syscalls
    const hasSyscalls = bytecodeAnalysis.syscalls.length > 0;
    checks.push({
      id: 'CHK_SYSCALLS',
      name: 'Syscall Usage',
      category: 'Runtime',
      status: 'PASSED',
      severity: 'INFORMATIONAL',
      description: `${bytecodeAnalysis.syscalls.length} syscalls used`,
      details: bytecodeAnalysis.syscalls.join(', '),
    });

    // Check 7: Deployer Reputation
    let deployerStatus: CheckStatus = 'NOT_APPLICABLE';
    let deployerDesc = 'Deployer information not available';

    if (programInfo.deployerHistory) {
      const rep = programInfo.deployerHistory.reputation;
      deployerStatus = rep === 'TRUSTED' ? 'PASSED' : rep === 'ESTABLISHED' ? 'PASSED' : 'WARNING';
      deployerDesc = `${rep} deployer (${programInfo.deployerHistory.walletAge} days old)`;
    }

    checks.push({
      id: 'CHK_DEPLOYER',
      name: 'Deployer Reputation',
      category: 'Trust',
      status: deployerStatus,
      severity: 'MEDIUM',
      description: deployerDesc,
    });

    // Check 8: Account Validation
    const avgValidation = bytecodeAnalysis.accountsUsed.filter(
      a => a.validationLevel === 'STRICT'
    ).length / Math.max(bytecodeAnalysis.accountsUsed.length, 1);

    checks.push({
      id: 'CHK_ACCOUNTS',
      name: 'Account Validation Level',
      category: 'Data Validation',
      status: avgValidation > 0.5 ? 'PASSED' : avgValidation > 0.2 ? 'WARNING' : 'FAILED',
      severity: 'HIGH',
      description: `${(avgValidation * 100).toFixed(0)}% of accounts have strict validation`,
    });

    return checks;
  }

  /**
   * Create vulnerability from pattern
   */
  private createVulnerability(
    patternId: string,
    overrides: Partial<Vulnerability>
  ): Vulnerability {
    const pattern = this.patterns.find(p => p.id === patternId);

    if (!pattern) {
      throw new Error(`Unknown vulnerability pattern: ${patternId}`);
    }

    return {
      id: generateAuditId(),
      name: pattern.name,
      severity: pattern.severity,
      category: pattern.category,
      description: overrides.description || pattern.description,
      impact: overrides.impact || pattern.description,
      location: overrides.location,
      recommendation: pattern.recommendation,
      references: pattern.references,
      cweId: pattern.cweId,
      confidence: overrides.confidence || 0.5,
    };
  }

  /**
   * Sort vulnerabilities by severity
   */
  private sortBySeverity(vulnerabilities: Vulnerability[]): Vulnerability[] {
    return [...vulnerabilities].sort(
      (a, b) => severityToNumber(b.severity) - severityToNumber(a.severity)
    );
  }
}

export default VulnerabilityDetector;
